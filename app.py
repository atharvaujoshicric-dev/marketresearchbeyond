import streamlit as st
import pandas as pd
import re
import io
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email.utils import formataddr
from email import encoders
from openpyxl.styles import Alignment, PatternFill, Border, Side

# --- EMAIL CONFIGURATION ---
SENDER_EMAIL = "atharvaujoshi@gmail.com"
SENDER_NAME = "Spydarr Market Research" 
APP_PASSWORD = "nybl zsnx zvdw edqr"

def send_email(recipient_email, excel_data, filename):
    try:
        recipient_name = recipient_email.split('@')[0].replace('.', ' ').title()
        msg = MIMEMultipart()
        msg['From'] = formataddr((SENDER_NAME, SENDER_EMAIL))
        msg['To'] = recipient_email
        msg['Subject'] = "Spydarr Market Research Summary"
        
        # FIXED: Using triple quotes for multi-line f-string to avoid SyntaxError
        body = f"""Dear {recipient_name},

Please find the attached professional property analysis report generated by the dashboard.

The report includes:
1. Raw Data with calculated APR and Configurations.
2. A summarized view of APR statistics across properties.

Regards,
Atharva Joshi"""

        msg.attach(MIMEText(body, 'plain'))
        part = MIMEBase('application', 'octet-stream')
        part.set_payload(excel_data)
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f"attachment; filename= {filename}")
        msg.attach(part)
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(SENDER_EMAIL, APP_PASSWORD)
        server.send_message(msg)
        server.quit()
        return True
    except Exception as e:
        st.error(f"Error sending email: {e}")
        return False

def extract_area_logic(text):
    if pd.isna(text) or text == "": return 0.0
    text = " ".join(str(text).split())
    m_unit = r'(?:चौरस\s*मी[टत]र|चौ[\.\s]*मी|चाै[\.\s]*मी|sq\.?\s*m(?:tr)?\.?|square\s*meter(?:s)?)'
    f_unit = r'(?:चौरस\s*फु[टत]|चौरस\s*फू[टत]|चौ[\.\s]*फू|चाै[\.\s]*फू|चौ[\.\s]*फुट|चाै[\.\s]*फुट|sq\.?\s*f(?:t)?\.?|square\s*f(?:ee|oo)t)'
    exclude_keywords = ["पार्किंग", "पार्कींग", "parking", "land", "survey", "सर्वे", "जमीन", "मिळकतीवर", "एकूण क्षेत्र", "क्षेत्र 442.9" , "road" , "reserve"]
    include_keywords = ["सदनिका", "फ्लॅट", "युनिट", "रूम", "flat", "unit", "room", "अपार्टमेंट", "सेंकड"]
    m_vals = []
    for match in re.finditer(rf'(\d+\.?\d*)\s*{m_unit}', text, re.IGNORECASE):
        val = float(match.group(1))
        context_before = text[max(0, match.start()-70):match.start()].lower()
        is_excluded = any(word in context_before for word in exclude_keywords)
        is_unit_specific = any(word in context_before for word in include_keywords)
        if 2.0 <= val < 600:
            if is_unit_specific or not is_excluded:
                m_vals.append(val)
    if m_vals: return round(sum(m_vals), 3)
    f_vals = []
    for match in re.finditer(rf'(\d+\.?\d*)\s*{f_unit}', text, re.IGNORECASE):
        val = float(match.group(1))
        context_before = text[max(0, match.start()-70):match.start()].lower()
        is_excluded = any(word in context_before for word in exclude_keywords)
        is_unit_specific = any(word in context_before for word in include_keywords)
        if 20.0 <= val < 6000:
            if is_unit_specific or not is_excluded:
                f_vals.append(val)
    if f_vals: return round(sum(f_vals) / 10.764, 3)
    return 0.0

def determine_config(area, t1, t2, t3):
    if area == 0: return "N/A"
    if area < t1: return "1 BHK"
    elif area < t2: return "2 BHK"
    elif area < t3: return "3 BHK"
    else: return "4 BHK"

def apply_excel_formatting(df, writer, sheet_name, is_summary=True):
    df.to_excel(writer, sheet_name=sheet_name, index=False)
    worksheet = writer.sheets[sheet_name]
    worksheet.freeze_panes = "A2"
    center_align = Alignment(horizontal='center', vertical='center')
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    colors = ["A2D2FF", "FFD6A5", "CAFFBF", "FDFFB6", "FFADAD", "BDB2FF", "9BF6FF"]
    color_idx, start_row_prop, start_row_cfg = 0, 2, 2
    
    for i in range(1, worksheet.max_row + 1):
        for j in range(1, worksheet.max_column + 1):
            cell = worksheet.cell(row=i, column=j)
            cell.alignment = center_align
            if is_summary: cell.border = thin_border
            
    if is_summary:
        last_col = len(df.columns)
        for i in range(2, len(df) + 2):
            curr_prop = df.iloc[i-2, 0]
            next_prop = df.iloc[i-1, 0] if i-1 < len(df) else None
            fill = PatternFill(start_color=colors[color_idx % len(colors)], end_color=colors[color_idx % len(colors)], fill_type="solid")
            for col in range(1, last_col + 1):
                worksheet.cell(row=i, column=col).fill = fill
            if curr_prop != next_prop:
                if i > start_row_prop: 
                    worksheet.merge_cells(start_row=start_row_prop, start_column=1, end_row=i, end_column=1)
                    # Merging the Total Count column (Last Column)
                    worksheet.merge_cells(start_row=start_row_prop, start_column=last_col, end_row=i, end_column=last_col)
                color_idx += 1
                start_row_prop = i + 1
            curr_cfg_key = [df.iloc[i-2, 0], df.iloc[i-2, 2]] 
            next_cfg_key = [df.iloc[i-1, 0], df.iloc[i-1, 2]] if i-1 < len(df) else None
            if curr_cfg_key != next_cfg_key:
                if i > start_row_cfg: 
                    worksheet.merge_cells(start_row=start_row_cfg, start_column=2, end_row=i, end_column=2)
                    worksheet.merge_cells(start_row=start_row_cfg, start_column=3, end_row=i, end_column=3)
                start_row_cfg = i + 1

# --- STREAMLIT UI ---
st.set_page_config(page_title="Spydarr Dashboard", layout="wide")
st.title("Spydarr Dashboard")
st.markdown("<div style='margin-top: -15px; margin-bottom: 10px;'><span style='background-color: #FFFF00; padding: 2px 8px; border-radius: 4px; border: 1px solid #E6E600; font-size: 0.9em; color: black;'><u><strong>NOTE :-</strong> Please cross-check the report manually.</u></span></div>", unsafe_allow_html=True)
st.divider()

st.sidebar.header("Calculation Settings")
loading_factor = st.sidebar.number_input("Loading Factor", min_value=1.0, value=1.35, step=0.001, format="%.3f")
t1, t2, t3 = st.sidebar.number_input("1 BHK Threshold", value=600), st.sidebar.number_input("2 BHK Threshold", value=850), st.sidebar.number_input("3 BHK Threshold", value=1100)

uploaded_file = st.file_uploader("Upload Data File", type=["xlsx", "csv"])
if uploaded_file:
    df = pd.read_csv(uploaded_file) if uploaded_file.name.endswith('.csv') else pd.read_excel(uploaded_file)
    clean_cols = {c.lower().strip(): c for c in df.columns}
    desc_col, cons_col, prop_col, date_col = clean_cols.get('property description'), clean_cols.get('consideration value'), clean_cols.get('property'), clean_cols.get('completion date')
    
    if desc_col and cons_col and prop_col and date_col:
        with st.spinner('Calculating...'):
            df['Carpet Area (SQ.MT)'] = df[desc_col].apply(extract_area_logic)
            df['Carpet Area (SQ.FT)'] = (df['Carpet Area (SQ.MT)'] * 10.764).round(3)
            df['Saleable Area'] = (df['Carpet Area (SQ.FT)'] * loading_factor).round(3)
            df['APR'] = df.apply(lambda r: round(r[cons_col]/r['Saleable Area'], 3) if r['Saleable Area'] > 0 else 0, axis=1)
            df['Configuration'] = df['Carpet Area (SQ.FT)'].apply(lambda x: determine_config(x, t1, t2, t3))
            df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
            
            calc_cols = ['Carpet Area (SQ.MT)', 'Carpet Area (SQ.FT)', 'Saleable Area', 'APR', 'Configuration']
            df = df[[c for c in df.columns if c not in calc_cols] + calc_cols]
            valid_df = df[df['Carpet Area (SQ.FT)'] > 0].sort_values([prop_col, 'Configuration', 'Carpet Area (SQ.FT)'])
            
            # Grouping Summary
            total_project_counts = valid_df.groupby(prop_col).size().reset_index(name='Total Count')
            summary = valid_df.groupby([prop_col, 'Configuration', 'Carpet Area (SQ.FT)']).agg(
                Last_Date=(date_col, 'max'),
                Min_APR=('APR', 'min'), 
                Max_APR=('APR', 'max'), 
                Avg_APR=('APR', 'mean'),
                Median_APR=('APR', 'median'),
                Property_Count=(prop_col, 'count')
            ).reset_index()
            
            summary = summary.merge(total_project_counts, on=prop_col, how='left')
            summary['Last_Date'] = summary['Last_Date'].dt.strftime('%d-%m-%Y')
            summary = summary[[prop_col, 'Last_Date', 'Configuration', 'Carpet Area (SQ.FT)', 'Min_APR', 'Max_APR', 'Avg_APR', 'Median_APR', 'Property_Count', 'Total Count']]
            summary.columns = ['Property', 'Last Completion Date', 'Configuration', 'Carpet Area(SQ.FT)', 'Min. APR', 'Max APR', 'Average of APR', 'Median of APR', 'Count of Property', 'Total Count']
            summary[['Min. APR', 'Max APR', 'Average of APR', 'Median of APR']] = summary[['Min. APR', 'Max APR', 'Average of APR', 'Median of APR']].round(3)

            output = io.BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                apply_excel_formatting(df, writer, 'Raw Data', is_summary=False)
                apply_excel_formatting(summary, writer, 'Summary', is_summary=True)
            
            st.success("Analysis Complete!")
            recipient = st.text_input("Recipient Name", placeholder="firstname.lastname")
            if st.button("Send to Email") and recipient:
                # FIXED: Added strip().lower() to ensure email construction is clean
                if send_email(f"{recipient.strip().lower()}@beyondwalls.com", output.getvalue(), "Spydarr_Market_Report.xlsx"):
                    st.success("Sent!")
    else:
        st.error("Missing required columns.")
