import streamlit as st
import pandas as pd
import re
import io
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email.utils import formataddr
from email import encoders
from openpyxl.styles import Alignment, PatternFill, Border, Side

# --- EMAIL CONFIGURATION ---
SENDER_EMAIL = "atharvaujoshi@gmail.com"
SENDER_NAME = "Spydarr Market Research" 
APP_PASSWORD = "nybl zsnx zvdw edqr"

def send_email(recipient_email, excel_data, filename):
    try:
        recipient_name = recipient_email.split('@')[0].replace('.', ' ').title()
        msg = MIMEMultipart()
        msg['From'] = formataddr((SENDER_NAME, SENDER_EMAIL))
        msg['To'] = recipient_email
        msg['Subject'] = "Property Analysis Report - Ready for Review"

        body = f"""Dear {recipient_name},
        
Please find the attached professional property analysis report generated by the dashboard.

Regards,
Atharva Joshi
        """
        msg.attach(MIMEText(body, 'plain'))

        part = MIMEBase('application', 'octet-stream')
        part.set_payload(excel_data)
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f"attachment; filename= {filename}")
        msg.attach(part)

        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(SENDER_EMAIL, APP_PASSWORD)
        server.send_message(msg)
        server.quit()
        return True
    except Exception as e:
        st.error(f"Error sending email: {e}")
        return False

def extract_area_logic(text):
    if pd.isna(text) or text == "": return 0.0
    
    # 1. Cleanup: Standardize spaces and specific Marathi characters
    text = " ".join(str(text).split())
    text = text.replace(' ,', ',').replace(', ', ',')
    
    # Super-Regex for Metric (SQ.MT) - Catches à¤šà¥Œ, à¤šà¤¾à¥ˆ, à¤šà¥Œ., Sq.Mt, etc.
    m_unit = r'(?:à¤šà¥Œà¤°à¤¸\s*à¤®à¥€[à¤Ÿà¤¤]à¤°|à¤šà¥Œ[\.\s]*à¤®à¥€[\.\s]*|à¤šà¤¾à¥ˆ[\.\s]*à¤®à¥€[\.\s]*|sq\.?\s*m(?:tr)?\.?|square\s*meter(?:s)?)'
    
    # Super-Regex for Imperial (SQ.FT) - Catches à¤šà¥Œ.à¤«à¥‚., à¤šà¥Œà¤°à¤¸ à¤«à¥‚à¤Ÿ, Sq.Ft, etc.
    f_unit = r'(?:à¤šà¥Œà¤°à¤¸\s*à¤«à¥[à¤Ÿà¤¤]|à¤šà¥Œ[\.\s]*à¤«à¥‚[\.\s]*|à¤šà¤¾à¥ˆ[\.\s]*à¤«à¥‚[\.\s]*|à¤šà¥Œ[\.\s]*à¤«à¥à¤Ÿ|à¤šà¤¾à¥ˆ[\.\s]*à¤«à¥à¤Ÿ|sq\.?\s*f(?:t)?\.?|square\s*f(?:ee|oo)t)'
    
    total_keywords = r'(?:à¤[à¤•à¤•à¥]à¤£\s*à¤•à¥à¤·à¥‡à¤¤à¥à¤°|à¤•à¥à¤·à¥‡à¤¤à¥à¤°à¤«à¤³|à¤•à¤¾à¤°à¥à¤ªà¥‡à¤Ÿ\s*à¤•à¥à¤·à¥‡à¤¤à¥à¤°|carpet\s*area|total\s*area)'
    parking_keywords = ["à¤ªà¤¾à¤°à¥à¤•à¤¿à¤‚à¤—", "à¤ªà¤¾à¤°à¥à¤•à¥€à¤‚à¤—", "parking", "land", "survey", "à¤¸à¤°à¥à¤µà¥‡", "à¤®à¤¿à¤³à¤•à¤¤"]

    # --- STEP 1: METRIC EXTRACTION ---
    m_segments = re.split(f'(\d+\.?\d*)\s*{m_unit}', text, flags=re.IGNORECASE)
    m_vals = []
    if len(m_segments) > 1:
        for i in range(1, len(m_segments), 2):
            val = float(m_segments[i])
            context_before = m_segments[i-1].lower()
            is_parking = any(word in context_before for word in parking_keywords)
            
            # Logic: If it's a single flat, take it. If multi-flat, we limit to reasonable size.
            if 10 < val < 500 and not is_parking:
                m_vals.append(val)
        
        if m_vals:
            # If "Total Area" keyword exists, prioritize that specific number
            t_m_match = re.search(rf'{total_keywords}\s*:?\s*(\d+\.?\d*)\s*{m_unit}', text, re.IGNORECASE)
            if t_m_match: return round(float(t_m_match.group(1)), 3)
            # Otherwise return sum (e.g. Carpet + Terrace)
            return round(sum(m_vals), 3)

    # --- STEP 2: FALLBACK TO IMPERIAL ---
    f_segments = re.split(f'(\d+\.?\d*)\s*{f_unit}', text, flags=re.IGNORECASE)
    f_vals = []
    if len(f_segments) > 1:
        for i in range(1, len(f_segments), 2):
            val = float(f_segments[i])
            context_before = f_segments[i-1].lower()
            is_parking = any(word in context_before for word in parking_keywords)
            
            if 100 < val < 5000 and not is_parking:
                f_vals.append(val)
        
        if f_vals:
            t_f_match = re.search(rf'{total_keywords}\s*:?\s*(\d+\.?\d*)\s*{f_unit}', text, re.IGNORECASE)
            # For complex multi-flat strings (like Example 3), we take the first valid area found
            if "à¤…à¤ªà¤¾à¤°à¥à¤Ÿà¤®à¥‡à¤‚à¤Ÿ à¤¨à¤‚" in text or "à¤¸à¤¦à¤¨à¤¿à¤•à¤¾" in text:
                return round(f_vals[0] / 10.764, 3)
            
            if t_f_match: return round(float(t_f_match.group(1)) / 10.764, 3)
            return round(sum(f_vals) / 10.764, 3)

    return 0.0

def determine_config(area, t1, t2, t3):
    if area == 0: return "N/A"
    if area < t1: return "1 BHK"
    elif area < t2: return "2 BHK"
    elif area < t3: return "3 BHK"
    else: return "4 BHK"

def apply_excel_formatting(df, writer, sheet_name, is_summary=True):
    df.to_excel(writer, sheet_name=sheet_name, index=False)
    worksheet = writer.sheets[sheet_name]
    worksheet.freeze_panes = "A2"
    
    center_align = Alignment(horizontal='center', vertical='center')
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    colors = ["A2D2FF", "FFD6A5", "CAFFBF", "FDFFB6", "FFADAD", "BDB2FF", "9BF6FF"]
    
    color_idx = 0
    start_row_prop = 2
    start_row_cfg = 2
    
    for i in range(1, worksheet.max_row + 1):
        for j in range(1, worksheet.max_column + 1):
            cell = worksheet.cell(row=i, column=j)
            cell.alignment = center_align
            if is_summary: cell.border = thin_border

    if is_summary:
        for i in range(2, len(df) + 2):
            curr_prop = df.iloc[i-2, 0]
            next_prop = df.iloc[i-1, 0] if i-1 < len(df) else None
            fill = PatternFill(start_color=colors[color_idx % len(colors)], end_color=colors[color_idx % len(colors)], fill_type="solid")
            for col in range(1, len(df.columns) + 1):
                worksheet.cell(row=i, column=col).fill = fill
            if curr_prop != next_prop:
                if i > start_row_prop: worksheet.merge_cells(start_row=start_row_prop, start_column=1, end_row=i, end_column=1)
                color_idx += 1
                start_row_prop = i + 1
            curr_cfg_key = [df.iloc[i-2, 0], df.iloc[i-2, 1]]
            next_cfg_key = [df.iloc[i-1, 0], df.iloc[i-1, 1]] if i-1 < len(df) else None
            if curr_cfg_key != next_cfg_key:
                if i > start_row_cfg: worksheet.merge_cells(start_row=start_row_cfg, start_column=2, end_row=i, end_column=2)
                start_row_cfg = i + 1

# --- STREAMLIT UI ---
st.set_page_config(page_title="Real Estate Analytics", layout="wide")
st.sidebar.header("Calculation Settings")
loading_factor = st.sidebar.number_input("Loading Factor", min_value=1.0, value=1.35, step=0.001, format="%.3f")
t1 = st.sidebar.number_input("1 BHK Threshold (<)", value=600)
t2 = st.sidebar.number_input("2 BHK Threshold (<)", value=850)
t3 = st.sidebar.number_input("3 BHK Threshold (<)", value=1100)

uploaded_file = st.file_uploader("Upload Data File (.xlsx or .csv)", type=["xlsx", "csv"])

if uploaded_file:
    if uploaded_file.name.endswith('.csv'):
        df = pd.read_csv(uploaded_file)
    else:
        df = pd.read_excel(uploaded_file)

    clean_cols = {c.lower().strip(): c for c in df.columns}
    desc_col = clean_cols.get('property description')
    cons_col = clean_cols.get('consideration value')
    prop_col = clean_cols.get('property')
    
    if desc_col and cons_col and prop_col:
        with st.spinner('Running Super-Regex Logic...'):
            df['Carpet Area (SQ.MT)'] = df[desc_col].apply(extract_area_logic)
            df['Carpet Area (SQ.FT)'] = (df['Carpet Area (SQ.MT)'] * 10.764).round(3)
            df['Saleable Area'] = (df['Carpet Area (SQ.FT)'] * loading_factor).round(3)
            df['APR'] = df.apply(lambda r: round(r[cons_col]/r['Saleable Area'], 3) if r['Saleable Area'] > 0 else 0, axis=1)
            df['Configuration'] = df['Carpet Area (SQ.FT)'].apply(lambda x: determine_config(x, t1, t2, t3))
            
            calc_cols = ['Carpet Area (SQ.MT)', 'Carpet Area (SQ.FT)', 'Saleable Area', 'APR', 'Configuration']
            other_cols = [c for c in df.columns if c not in calc_cols]
            df = df[other_cols + calc_cols]

            valid_df = df[df['Carpet Area (SQ.FT)'] > 0].sort_values([prop_col, 'Configuration', 'Carpet Area (SQ.FT)'])
            summary = valid_df.groupby([prop_col, 'Configuration', 'Carpet Area (SQ.FT)']).agg(
                Min_APR=('APR', 'min'), Max_APR=('APR', 'max'), Avg_APR=('APR', 'mean'),
                Median_APR=('APR', 'median'),
                Mode_APR=('APR', lambda x: x.mode().iloc[0] if not x.mode().empty else 0),
                Property_Count=(prop_col, 'count')
            ).reset_index()
            summary.columns = ['Property', 'Configuration', 'Carpet Area(SQ.FT)', 'Min. APR', 'Max APR', 'Average of APR', 'Median of APR', 'Mode of APR', 'Count of Property']
            summary[['Min. APR', 'Max APR', 'Average of APR', 'Median of APR', 'Mode of APR']] = summary[['Min. APR', 'Max APR', 'Average of APR', 'Median of APR', 'Mode of APR']].round(3)

            output = io.BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                apply_excel_formatting(df, writer, 'Raw Data', is_summary=False)
                apply_excel_formatting(summary, writer, 'Summary', is_summary=True)
            
            processed_data = output.getvalue()
            st.success("Analysis Complete!")
            
            st.markdown("---")
            st.subheader("ðŸ“© Email the Report")
            recipient = st.text_input("Enter Email Address", placeholder="example@domain.com")
            if st.button("Send to Email"):
                if recipient:
                    with st.spinner("Sharing report..."):
                        if send_email(recipient, processed_data, "Property_Market_Report.xlsx"):
                            st.success(f"Report sent successfully to {recipient}!")
                            st.balloons()
                else:
                    st.error("Please enter a recipient email.")
    else:
        st.error("Required columns missing.")
